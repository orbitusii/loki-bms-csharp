# DEVELOPERS: Program Overview
## UI Framework
LOKI BMS uses the [Windows Presentation Foundation](https://learn.microsoft.com/en-us/dotnet/desktop/wpf/overview/?view=netdesktop-6.0) framework for its basic UI. To that end, it generally follows a Model-View-ViewModel pattern, albeit limited by my own programming skills.

As of 25 November 2022, there are three main windows within the application:
- The Main Scope
- Data Sources
- Geometry

Behavior for each of those windows is covered in the relevant page (WIP).

## Basic Application Flow
The entry point is auto-generated code as of 25 November 2022. This autogenerated entry point then calls OnStartup() within App.xaml.cs to accomplish program initialization, then continues to open the rest of the application.

### Initialization
- `TrackNumber.Test()` is a quick test case to ensure proper comparison of TrackNumber objects - this needs to be relocated into a proper Test suite/subproject.
- `ProgramData.Initialize()` is where most of the interesting behavior happens
  - Load symbology paths for tracks and TrackDatums from DataSources from resource files
  - Load landmass geometry from resource files and user-defined geometries from `%appdata%/Loki-BMS/Geometry.xml`
  - Load View Settings from `%appdata%/Loki-BMS/Views.xml` - this includes the latest view center, zoom level, and zoom presets
    - A TangentMatrix will be computed for the loaded view center to be ready for rendering after initialization is complete
  - Load Data Sources from `%appdata%/Loki-BMS/DataSources.xml` - sources will be activated automatically if they were active on the last application close
    - Data Sources with no track number range will have one automatically assigned
  - Geometry paths are cached according to the ViewSettings' Camera Matrix, and the `ViewSettings.OnViewCenterChanged` callback is populated with `GeometrySettings.CacheGeometry()` to ensure the cached paths are updated when the view center changes
- `TrackDatabase.Initialize(*float tickRate*)` sets up the TrackDatabase, which initializes the lists within the Database and configures it to update all live tracks every *tickRate* milliseconds
  - This tick rate is independent of DataSources getting new data from their servers
  - Due to some instability at low *tickRate* values (e.g. tracks flying off to space in a straight line), LOKI updates the Database once every 1000ms, or at 1Hz

Initialization is now complete, and the program can continue to load into the Main Scope.

### Threading
There are only a few threads within LOKI as of 25 November 2022 that direct the behavior and interaction of LOKI.
- The UI thread(s), tied to the WPF windows
- The Database Update thread
- A thread for each DataSource, which handles the connection attempt/retry and data streaming processes so that they are non-blocking for other processes that may continue while a DataSource is stuck waiting for a response from the server

## Scope Rendering
Most of LOKI's UI is accomplished with native WPF controls and behavior, with the notable exception being the Main Scope's ScopeCanvas control. This control is an SKElement from the SkiaSharp library.

Rendering to this control is abstracted through an instance of the ScopeRenderer class, which is constructed alongside the Main Scope window during Application Initialization. Most of this is not seen by other classes, as the ScopeRenderer reaches out and grabs the things it needs for drawing from the other classes only as needed. The only truly exposed method for controlling rendering of the scope is the Main Scope window's `Redraw()` method. (The specifics of this may be adjusted later on)

The Main Scope window's `Redraw()` method provides a thread-safe way to demand the ScopeRenderer be redrawn ASAP. Calling Redraw() on the Main Scope window passes that call through the Main Scope's dispatcher, which ensures that the call is accomplished in time with the window's UI thread, and not out of sync due to the many threads within LOKI.

### Geometry Caching
MapGeometry objects, which are parsed from KML or SVG files, store their paths as Path3D objects, which each contain arrays of Vector64s, or 64-bit euclidian vectors. Due to the nature of rendering to computer screens, which are 2D surfaces, these 3D paths need to be converted to 2D paths such that they appear correctly.

The process of converting these 3D paths to 2D paths for final rendering is outlined below:
1. Using the CameraMatrix stored in ViewSettings, each Vector64 undergoes a change of base to camera space - negative X is into or through the screen, positive Y is right on screen, positive Z is up on the screen
    - Camera projection is orthographic, meaning distance from the camera, -X, is not taken into account except for culling
2. A new point is created from the Y and Z components, in that order, of the camera-space Vector64
    - If a point's distance from the camera is greater than the Earth's radius (as the camera is considered to rest exactly on the surface), that point will be snapped to the horizon line, as it is beyond the horizon (insert diagram here)
    - Each point beyond the horizon will increment a counter by 1
3. These points are recombined into a new SkiaSharp Path (SKPath) that can be rendered
    - However, if the number of points beyond the horizon is equal to the number of points in the original path, no points will be added to the SKPath, effectively culling it
4. This new SKPath is cached
5. When the ScopeRenderer goes to draw all MapGeometry paths, it will first clone the original cached path to non-destructively transform it to fit on screen
    - This transformation includes a translation, by half of the ScopeCanvas's size, and a scale factor based on the zoom level
    - If the cloned path passes a frustrum check, it will be drawn

Due to the relative complexity of this caching process, it is not accomplished every `Redraw()`. The 2D-projected paths will only change if the CameraMatrix changes, which only happens if the user changes their view. Thus, MapGeometry classes only need to re-cache their paths when `ViewSettings.OnViewCenterChanged` is called - this delegate/callback is set up during program initialization.